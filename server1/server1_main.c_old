/*
 * ===============================
 * AUTHOR		: Manuel Scurti
 * STUDENT ID 	: 251175
 *
 * File transfer mechanism
 * 		Client -> GET filename\r\n
 * 		Server -> +OK B1 B2 B3 B4 T1 T2 T3 T4 file content.
 * 				or -ERR
 *
 * SERVER SIDE
 * ===============================
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include "../sockwrap.h"
#include "../errlib.h"

#define BUFSIZE 4096
//#define TRANSFERBUFFER 256 /* bytes */
#define FILENAMELEN 256
#define ERRSTR "-ERR\r\n"
#define ERRSTRLEN 6
#define BACKLOG 4
#define _DEBUG

char *prog_name;

int setup_server(char* port_num);
void handle_file_req(int socket);
int send_file(int skt, char *filename);

int main (int argc, char *argv[])
{
	int answer_socket,s;
	struct sockaddr_in caddr;
	socklen_t addrlen;

	prog_name = argv[0];
	if(argc!=2)
	{
		printf("Usage: %s <port num>\n",prog_name);
		exit(1);
	}

	answer_socket = setup_server(argv[1]); //returns initialized socket
	printf("Server is running.\n");

	for(;;)
	{
		addrlen = sizeof(struct sockaddr_in);
		s = Accept(answer_socket, (struct sockaddr *) &caddr, &addrlen);

        handle_file_req(s);
	}
}

int setup_server(char* port_num)
{
	int s; //socket container
	uint16_t port_n,port_h;
	struct sockaddr_in saddr;

    if (sscanf(port_num, "%" SCNu16, &port_h)!=1)
		err_sys("Invalid port number");
    port_n = htons(port_h);

    s = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

    bzero(&saddr, sizeof(saddr));
    saddr.sin_family      = AF_INET;
    saddr.sin_port        = port_n;
    saddr.sin_addr.s_addr = INADDR_ANY;
    Bind(s, (struct sockaddr *) &saddr, sizeof(saddr));

    /* listen */
	Listen(s, BACKLOG);

    return s;
}

void handle_file_req(int skt)
{
	char r_buf[BUFSIZE];
	char filename[FILENAMELEN];
	ssize_t count_rcv; //coudnter of received chars

    for(;;)
    {
        printf("HANDLE LOOP\n");
        count_rcv = readline_unbuffered(skt,r_buf,BUFSIZE);
        printf("r_buf contents: \n%s\n",r_buf);

        if (count_rcv < 0)
	    {
	       printf("Read error\n");
	       break;
	    }
	    else if (count_rcv == 0)
	    {
	       printf("Connection closed by party on socket %d\n",skt);
	       break;
	    }
	    else
	    {
            r_buf[count_rcv] = '\0';

            /* check format of client's request */
            printf("new req: %s\n", r_buf);

            if(sscanf(r_buf,"GET %s\r\n",filename)==1)
            {
                if(send_file(skt,filename)==0)
                    printf("%s sent!\n",filename);
                else
                {
                    printf("Error: file not sent.\n");
                    Send(skt,ERRSTR,ERRSTRLEN,0);
                    break;
                }
            }
            else if (strcmp(r_buf,"QUIT\r\n")==0)
            {
                printf("Connection closed. QUIT received.\n");
                break;
            }
        }
        r_buf[0]='\0';
	}
	close(skt);
}

int send_file(int skt, char *filename)
{
    FILE *fp;
    int fd;

    fp = fopen(filename, "r");
    if(fp==NULL){
        printf("\"%s\" not available in this file system.\n",filename);
        return -1;
    }

    fd = fileno(fp); //takes file descriptor from file pointer
    struct stat fileStat;
    if(fstat(fd,&fileStat) < 0){
        printf("Error while retreiving file stats.\n");
        return -1;
    }

    off_t fsize = fileStat.st_size;
    time_t ftimestamp = fileStat.st_mtime;
    uint32_t fsize32 = htonl(fsize);
    uint32_t ftimestamp32 = htonl(ftimestamp);

    Sendn(skt,"+OK\r\n",5*sizeof(char),0);
    Sendn(skt,&fsize32, sizeof(uint32_t), 0);
    Sendn(skt,&ftimestamp32, sizeof(uint32_t), 0);

    off_t bytes_left = fsize, file_ptr = 0;
    size_t numRead;
    ssize_t numSent;
    char s_buf[BUFSIZE];

    while (bytes_left > 0)
	{
        fseek(fp, file_ptr, SEEK_SET);
        numRead = fread(s_buf, sizeof(char), BUFSIZE, fp);
        if(ferror(fp)){
            printf("Error while reading file.\n");
            return -1;
        }

        printf("bytes_left: %zu\n",bytes_left);
        printf("numRead: %zu\n",numRead);

        numSent = writen(skt, s_buf, numRead);
        if(numSent != numRead){
            printf("Write error while replying\n");
            return -1;
        }
        else
            printf("Reply sent\n");

        printf("numSent: %zu\n",numSent);

        bytes_left -= numSent;
        file_ptr += numSent;
    }

    fseek(fp, 0, SEEK_SET);
    fclose(fp);

    printf("END FILE TRANSFER.\n");
    return 0;
}
/*
 * ===============================
 * AUTHOR		: Manuel Scurti
 * STUDENT ID 	: 251175
 * 
 * File transfer mechanism
 * 		Client -> GET filename\r\n
 * 		Server -> +OK B1 B2 B3 B4 T1 T2 T3 T4 file content.
 * 				or -ERR
 * 
 * CLIENT SIDE 
 * ===============================
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>
#include <sys/stat.h>
#include <sys/sendfile.h>
#include "../sockwrap.h"
#include "../errlib.h"

#define BUFSIZE 4096
#define REQMSG_LEN 6
#define FILENAMELEN 256
#define CLOSESTRING "QUIT\r\n"

char *prog_name;

int connect_to(char *ip, char *portnum);
int receive_file(int skt, char *filename);
int make_request(int skt, char *filename);
void close_link(int skt);

int main (int argc, char *argv[])
{

	int link; //socket descriptor
	int i=3, outcome, completed=0 /* completed downloads */, to_download = argc-i;


	printf("*** USER CLIENT ***\n");
	prog_name = argv[0];
	if(argc < 4)
	{
		printf("Usage: %s <ip address> <port num> <filename> [...]\n",prog_name);
		exit(1);
	}

	/* CONNECTION PHASE */
	printf("Connecting to %s:%s\n",argv[1],argv[2]);
	link = connect_to(argv[1],argv[2]); //error messages and behaviours are handled by errlib
	printf("Connected.\n");


	/* REQUEST PHASE */
	while(i < argc)
	{
		outcome = receive_file(link, argv[i]);
		if(outcome != -1)
			completed++;
		else printf("File \"%s\" skipped.\n",argv[i]);
		i++;
	}


	printf("Completed %d/%d file requests.\n", completed, to_download);
	printf("Shutting down connection...\n");
	close_link(link);

	printf("Bye!\n");
	return 0;
}

int connect_to(char *ip, char *portnum)
{
    uint16_t port_n, port_h;	/* server port number (net/host ord) */

	int s; //returning socket
	struct sockaddr_in saddr;		/* server address structure */
    struct in_addr server_ip; 	/* server IP addr. structure */

	Inet_aton(ip, &server_ip);


	if (sscanf(portnum, "%" SCNu16, &port_h)!=1)
		err_quit("Invalid port number");
	port_n = htons(port_h);

	s = Socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	bzero(&saddr, sizeof(saddr));
	saddr.sin_family = AF_INET;
	saddr.sin_port = port_n;
	saddr.sin_addr = server_ip;

	Connect(s, (struct sockaddr *) &saddr, sizeof(saddr));

	return s;
}

int receive_file(int skt, char *filename)
{
	FILE *fp;
	char r_buf[BUFSIZE];


	if((fp = fopen(filename,"w")) == NULL){
		printf("Unable to create file.\n");
		return -1;
	}
	//file is ready to be written

	if(make_request(skt,filename)==-1)
		return -1;

	/* Receiving file size */
	uint32_t file_size_n,fsize;
 	Recv(skt, &file_size_n, sizeof(uint32_t), 0);
    fsize = ntohl(file_size_n);

    printf("FILE SIZE: %"PRIu32"\n",fsize);

	/* Receiving file timestamp */
    uint32_t file_timestamp_n,file_timestamp;
 	Recv(skt, &file_timestamp_n, sizeof(uint32_t), 0);
    file_timestamp = ntohl(file_timestamp_n);

    printf("FILE TIMESTAMP: %"PRIu32"\n",file_timestamp);

    off_t bytes_left = fsize, file_ptr = 0;
    ssize_t numRecv;
    size_t numWritten;

    while (bytes_left > 0)
	{

        printf("bytes_left: %zu\n",bytes_left);

        numRecv = read(skt, r_buf, BUFSIZE);
        if(numRecv < 0)
        {
            printf("Error while receiving file contents.\n");
    		return -1;
        }
        printf("numRecv: %zu\n",numRecv);

        if(numRecv > 0)
        {
            //fseek(fp,file_ptr,SEEK_SET);
            numWritten = fwrite(r_buf,sizeof(char),numRecv,fp);
            if(numWritten != numRecv)
            {
                printf("Error while writing.\n");
                return -1;
            }
            printf("numWritten: %zu\n",numWritten);
        }

        bytes_left -= numWritten;
        file_ptr += numWritten;
    }

    fclose(fp);
    return 0;
}


int make_request(int skt, char *filename)
{
	char req_msg[REQMSG_LEN + FILENAMELEN];
	char r_buf[BUFSIZE];

	sprintf(req_msg,"GET %s\r\n",filename); //compose request message

	size_t len;
	len = strlen(req_msg);
	Send(skt,req_msg,len,0);

	/* Receive response */
	//checking if server responds with +ok
	len = Readline_unbuffered(skt,r_buf,BUFSIZE);
    r_buf[len] = '\0';

	if(strcmp(r_buf,"+OK\r\n")!=0)
	{
		printf("Negative response from server. rcv: %s\n",r_buf);
		return -1;
	}
	return 0;
}

void close_link(int skt)
{
	char close_msg[] = CLOSESTRING;

	size_t len;
	len = strlen(close_msg);
	if(write(skt,close_msg,len)!=len)
		printf("Unable to notify server of connection closing phase.\n");

	close(skt);
}
